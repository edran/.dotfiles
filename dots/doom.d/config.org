#+title: Doom Emacs Configuration
#+author: Nantas Nardelli
#+language: en
#+startup: fold
#+property: header-args:emacs-lisp :tangle yes :comments link :exports code
#+property: header-args :tangle no :results silent :eval no-export

* Preface

I have been using Emacs as my editor for more than a decade -- well before I
started calling myself a programmer -- and the journey has been quite the ride
so far.

My configuration has gone through many [[https://www.emacswiki.org/emacs/DotEmacsBankruptcy][bankruptcies]], including a bunch that
predate any usage (and knowledge!) of version control on my part. It's current
form, which most certainly is not its final (but which I hope to be its /present/
for at least a few more years), is based on the amazing =doom emacs= and =org-mode=.
Thanks to these frameworks, it is much, much slimmer than it used to be at
various points of its history.

Which is both good and bad. But /c'est la vie/ :)

** Basic usage info

In theory, the latest version of =doom emacs= should be able to simply run this
configuration. The first time, it needs to be generated via:

#+begin_src sh
$ doom sync  # generates config.el from tangling config.org
#+end_src

Afterwards, this org file will be tangled upon save, hopefully. If it's not the
case, =doom refresh= should do the job.

My main dev setup is a MBP running a heavily configured =MacOS 11=, but most
of this config should behave properly on modern linux distros so long as the
environment is configured similarly to what is provided by my [[https://github.com/edran/.dotfiles][dotfiles]].

** Known issues

This config is a /Forever Work In Progressâ„¢/, and thus there are things that I
wish were fixed / implemented that either I haven't had the time to tackle
and/or have the capabilities to properly do so.

*** TODO I would like hard wrap to work its magic on the paragraph automatically

Rather than the last sentence / lines.

*** TODO I should set bigger height for org headings only in the knowledge base

Since this makes some of the organizational files a little painful to manage.

*** TODO In org files, enter (in normal mode) should open links.

*** TODO indent-guides + mixed-pitch-mode messes up code blocks in org buffers

* Modules and Packages
** Doom modules
:PROPERTIES:
:header-args:emacs-lisp: :tangle no
:END:

#+name: init.el
#+attr_html: :collapsed t
#+begin_src emacs-lisp :tangle "init.el" :noweb no-export :comments no
;;; init.el -*- lexical-binding: t; -*-

;; This file controls what Doom modules get enabled and what order they load in.
;; Press 'K' on a module to view its documentation, and 'gd' to browse its directory.

(doom! :completion
       <<doom-completion>>

       :ui
       <<doom-ui>>

       :editor
       <<doom-editor>>

       :emacs
       <<doom-emacs>>

       :term
       <<doom-term>>

       :checkers
       <<doom-checkers>>

       :tools
       <<doom-tools>>

       :os
       <<doom-os>>

       :lang
       <<doom-lang>>

       :email
       <<doom-email>>

       :app
       <<doom-app>>

       :config
       <<doom-config>>
       )
#+end_src

*** Basics

#+name: doom-config
#+begin_src emacs-lisp
literate
(default +bindings +smartparens)
#+end_src

*** Interface

#+name: doom-completion
#+begin_src emacs-lisp
(company                     ; the ultimate code completion backend
 +childframe)                ; ... when your children are better than you
;; helm                      ; the *other* search engine for love and life
;; ido                       ; the other *other* search engine...
;; (ivy                      ; a search engine for love and life
;;  +icons                   ; ... icons are nice
;;  +prescient)              ; ... I know what I want(ed)
(vertico +icons)             ; the search engine of the futurecompany
#+end_src

#+name: doom-ui
#+begin_src emacs-lisp
deft                         ; notational velocity for Emacs
doom                         ; what makes DOOM look the way it does
doom-dashboard               ; a nifty splash screen for Emacs
;; doom-quit                    ; DOOM quit-message prompts when you quit Emacs
(emoji +unicode)             ; ðŸ™‚
;; fill-column               ; a `fill-column' indicator
hl-todo                      ; highlight TODO/FIXME/NOTE/DEPRECATED/HACK/REVIEW
;; hydra                     ; quick documentation for related commands
;; indent-guides             ; highlighted indent columns, notoriously slow
;; (ligatures +extra)           ; ligatures and symbols to make your code pretty again
;; minimap                   ; show a map of the code on the side
modeline                     ; snazzy, Atom-inspired modeline, plus API
nav-flash                    ; blink the current line after jumping
;; neotree                   ; a project drawer, like NERDTree for vim
ophints                      ; highlight the region an operation acts on
(popup                       ; tame sudden yet inevitable temporary windows
 +all                        ; catch all popups that start with an asterix
 +defaults)                  ; default popup rules
;; (tabs                     ; an tab bar for Emacs
;;   +centaur-tabs)          ; ... with prettier tabs
treemacs                     ; a project drawer, like neotree but cooler
;; unicode                   ; extended unicode support for various languages
vc-gutter                    ; vcs diff in the fringe
;; vi-tilde-fringe              ; fringe tildes to mark beyond EOB
(window-select +numbers)     ; visually switch windows
workspaces                   ; tab emulation, persistence & separate workspaces
zen                          ; distraction-free coding or writing
#+end_src

#+name: doom-editor
#+begin_src emacs-lisp
(evil +everywhere)           ; come to the dark side, we have cookies
file-templates               ; auto-snippets for empty files
fold                         ; (nigh) universal code folding
format                       ; automated prettiness
;; god                       ; run Emacs commands without modifier keys
;; lispy                     ; vim for lisp, for people who don't like vim
multiple-cursors             ; editing in many places at once
;; objed                     ; text object editing for the innocent
;; parinfer                  ; turn lisp into python, sort of
rotate-text                  ; cycle region at point between text candidates
snippets                     ; my elves. They type so I don't have to
;; word-wrap                 ; soft wrapping with language-aware indent
#+end_src

#+name: doom-emacs
#+begin_src emacs-lisp
(dired +icons)               ; making dired pretty [functional]
electric                     ; smarter, keyword-based electric-indent
;; (ibuffer +icons)             ; interactive buffer management
undo                         ; persistent, smarter undo for your inevitable mistakes
vc                           ; version-control and Emacs, sitting in a tree
#+end_src

#+name: doom-term
#+begin_src emacs-lisp
;; eshell                     ; the elisp shell that works everywhere
;; shell                      ; simple shell REPL for Emacs
;; term                       ; basic terminal emulator for Emacs
vterm                        ; the best terminal emulation in Emacs
#+end_src

#+name: doom-checkers
#+begin_src emacs-lisp
syntax                       ; tasing you for every semicolon you forget
(spell +aspell)              ; tasing you for misspelling mispelling
grammar                      ; tasing grammar mistake every you make
#+end_src

#+name: doom-tools
#+begin_src emacs-lisp
ansible                      ; a crucible for infrastructure as code
;; debugger                  ; FIXME stepping through code, to help you add bugs
;; direnv                    ; be direct about your environment
docker                       ; port everything to containers
;; editorconfig              ; let someone else argue about tabs vs spaces
;; ein                       ; tame Jupyter notebooks with emacs
(eval +overlay)              ; run code, run (also, repls)
;; gist                      ; interacting with github gists
(lookup                      ; helps you navigate your code and documentation
 +dictionary                 ; dictionary/thesaurus is nice
 +docsets)                   ; ...or in Dash docsets locally
lsp                          ; Language Server Protocol
;; macos                     ; MacOS-specific commands
(magit                       ; a git porcelain for Emacs
 +forge)                     ; interface with git forges
make                         ; run make tasks from Emacs
;; pass                      ; password manager for nerds
pdf                          ; pdf enhancements
;; prodigy                   ; FIXME managing external services & code builders
rgb                          ; creating color strings
;; taskrunner                ; taskrunner for all your projects
terraform                    ; infrastructure as code
;; tmux                         ; an API for interacting with tmux
;; upload                       ; map local to remote projects via ssh/ftp
#+end_src

#+name: doom-os
#+begin_src emacs-lisp
(:if IS-MAC macos)           ; *sigh*
;; tty                          ; improve the terminal Emacs experience
#+end_src

#+name: doom-lang
#+begin_src emacs-lisp
;; agda                       ; types of types of types of types...
;; beancount                  ; mind the GAAP
(cc +lsp)                     ; C/C++/Obj-C madness
;; clojure                    ; java with a lisp
;; common-lisp                ; if you've seen one lisp, you've seen them all
;; coq                        ; proofs-as-programs
;; crystal                    ; ruby at the speed of c
;; csharp                     ; unity, .NET, and mono shenanigans
data                          ; config/data formats
;; (dart +flutter)            ; paint ui and not much else
;; dhall                      ; JSON with FP sprinkles
;; elixir                     ; erlang done right
;; elm                        ; care for a cup of TEA?
emacs-lisp                    ; drown in parentheses
;; erlang                     ; an elegant language for a more civilized age
ess                           ; emacs speaks statistics
;; faust                      ; dsp, but you get to keep your soul
;; fsharp                     ; ML stands for Microsoft's Language
;; fstar                      ; (dependent) types and (monadic) effects and Z3
;; gdscript                   ; the language you waited for
;; (go +lsp)                  ; the hipster dialect
;; (haskell +lsp)             ; a language that's lazier than I am
;; hy                         ; readability of scheme w/ speed of python
;; idris                      ;
json                          ; At least it ain't XML
;; (java +meghanada)          ; the poster child for carpal tunnel syndrome
(javascript +lsp)             ; all(hope(abandon(ye(who(enter(here))))))
(julia +lsp)                  ; Python, R, and MATLAB in a blender
;; kotlin                     ; a better, slicker Java(Script)
(latex                        ; writing papers in Emacs has never been so fun
 +latexmk                     ; what else would you use?
 +cdlatex                     ; quick maths symbols
 +fold)                       ; fold the clutter away nicities
;; lean                       ; proof that mathematicians need help
;; factor                     ; for when scripts are stacked against you
;; ledger                     ; an accounting system in Emacs
lua                           ; one-based indices? one-based indices
markdown                      ; writing docs for people to ignore
;; nim                        ; python + lisp at the speed of c
;; nix                        ; I hereby declare "nix geht mehr!"
;; ocaml                      ; an objective camel
(org                          ; organize your plain life in plain text
 +dragndrop                   ; drag & drop files/images into org buffers
 ;; +hugo                     ; use Emacs for hugo blogging
 ;; +noter                       ; enhanced PDF notetaking
 +jupyter                     ; ipython/jupyter support for babel
 +pandoc                      ; export-with-pandoc support
 +gnuplot                     ; who doesn't like pretty pictures
 ;; +pomodoro                 ; be fruitful with the tomato technique
 +present                     ; using org-mode for presentations
 +pretty                      ; yessss my pretties! (nice unicode symbols)
 +roam2                       ; wander around notes
 )
;; php                        ; perl's insecure younger brother
;; plantuml                   ; diagrams for confusing people more
;; purescript                 ; javascript, but functional
(python                       ; beautiful is better than ugly
 +lsp
 +pyright
 +poetry)
;; qt                         ; the 'cutest' gui framework ever
;; racket                     ; a DSL for DSLs
;; raku                       ; the artist formerly known as perl6
;; rest                       ; Emacs as a REST client
;; rst                        ; ReST in peace
;; (ruby +rails)              ; 1.step {|i| p "Ruby is #{i.even? ? 'love' : 'life'}"}
(rust +lsp)                   ; Fe2O3.unwrap().unwrap().unwrap().unwrap()
;; scala                      ; java, but good
;; scheme                        ; a fully conniving family of lisps
sh                            ; she sells {ba,z,fi}sh shells on the C xor
;; sml                        ; no, the /other/ ML
;; solidity                   ; do you need a blockchain? No.
;; swift                      ; who asked for emoji variables?
;; terra                      ; Earth and Moon in alignment for performance.
web                           ; the tubes
yaml                          ; JSON, but readable
;; zig                        ; C, but simpler
#+end_src

#+name: doom-app
#+begin_src emacs-lisp
;; calendar                   ; A dated approach to timetabling
;; emms                       ; Multimedia in Emacs is music to my ears
everywhere                    ; *leave* Emacs!? You must be joking.
;; irc                        ; how neckbeards socialize
;; (rss +org)                 ; emacs as an RSS reader
;; twitter                    ; twitter client
#+end_src

** External packages
:PROPERTIES:
:header-args:emacs-lisp: :tangle "packages.el" :comments link
:END:

=doom= uses =packages.el= to contain user-provided packages. Any packaging code
present in the following headings will be tangled to that file. After editing
these section, a ~doom refresh~ is required.

*** How-to
:PROPERTIES:
:header-args:emacs-lisp: :tangle no
:END:

The packaging system is based on [[github:raxod502/straight.el][straight.el]], which has quite a nice [[https://github.com/raxod502/straight.el#the-recipe-format][recipe
format]]. On top of this, =doom= provides some useful macros:

#+begin_src emacs-lisp
;; if the  package is on MELPA / ELPA / Emacsmirror
(package! package-name)
;; if the package is on github and contains a PACKAGENAME.el
(package! package-name
  :recipe (:host github :repo "user/repo"))
;; otherwise...
(package! package-name
  :recipe (:host github :repo "user/repo"
           :files ("package-name.el" "lisp/*.el")))  ;; and so on...
#+end_src

Disabling a package that comes with doom is also fairly straightforward (however
it +will+ could have unintended consequences):

#+begin_src emacs-lisp
(package! package-name :disable t)
#+end_src

Packages can also be overridden with a fork quite easily (unspecified properties
will be inherited):

#+begin_src emacs-lisp
(package! package-name
  :recipe (:repo "user/package"
           :branch "develop"
           :nonrecursive t))
#+end_src

*** Disable byte compilation

Do not byte compile the tangled =.el= file.

#+begin_src emacs-lisp
;; -*- no-byte-compile: t; -*-
#+end_src

*** Org-mode extensions

The following packages make ~org-mode~ even more awesome than usual.

**** org-anki

~org-anki~ is a package I'm developing. Will be released Soonâ„¢.

#+begin_src emacs-lisp
(package! org-anki
  :recipe (:local-repo "lisp/org-anki"))
#+end_src

**** Prettier org-mode

~org-fragtog~ allows to toggle LaTeX previews.

#+begin_src emacs-lisp
(package! org-fragtog :pin "6806061...")
#+end_src

~org-pretty-tags~ makes it possible to replace boring tags with fun ones!

#+begin_src emacs-lisp
(package! org-pretty-tags :pin "e127a1e0...")
#+end_src

*** mathpix integration

[[https://mathpix.com/][Mathpix]] is a nifty tool that enables to transform pictures of math formulas into
LaTeX. Luckily, there's an emacs package that wraps its API.

#+begin_src emacs-lisp
(package! mathpix.el :pin "1ce2d4a..." :recipe (:host github :repo "jethrokuan/mathpix.el"))
#+end_src

*** Misc

=atomic-chrome= is used to enable editing text boxes with emacs.

#+begin_src emacs-lisp
(package! atomic-chrome)
#+end_src

=selectric-mode= is great for impressing people or for extremely angry coding.
Either way, worth it :)

#+begin_src emacs-lisp
(package! selectric-mode :pin "bb9e666...")
#+end_src

=info-colors= adds some colour to manual pages.

#+begin_src emacs-lisp
(package! info-colors :pin "47ee73c...")
#+end_src

* Essentials

Lexical binding can result into faster execution of this file (see
[[https://nullprogram.com/blog/2016/12/22/][this blog post]]), so we activate it. This is also the first line that gets
eventually pushed onto =config.el=.

#+begin_src emacs-lisp :comments no
;;; config.el -*- lexical-binding: t; -*-
#+end_src

** Personal info

These are some basic information that are necessary for e.g., =GPG=, =org-export=, etc.

#+begin_src emacs-lisp
(setq user-full-name "Nantas Nardelli"
      user-mail-address "nantas.nardelli@gmail.com")
#+end_src

** Setting the lab

I use =~/lab= as my root directory for pretty much all development work. This
helps some tools tinker with my data. /All hail automatic project management
software./

#+begin_src emacs-lisp
(defvar nn-lab-path "~/lab" "Path to the local laboratory")
#+end_src

At the moment, the only two lab-aware libraries are projectile and magit.

#+begin_src emacs-lisp
(setq projectile-project-search-path (list (cons nn-lab-path 2))
      magit-repository-directories (list (cons nn-lab-path 2)))
#+end_src

** Graphical configuration

All of this stuff relates to visual behaviour.

*** Fonts

#+begin_src emacs-lisp
;; (setq doom-font (font-spec :family "FiraCode Nerd Font" :size 12)
;;       doom-big-font (font-spec :family "FiraCode Nerd Font" :size 18)
;;       doom-variable-pitch-font (font-spec :family "Helvetica Neue" :size 18)
;;       doom-serif-font (font-spec :family "Times New Roman" :weight 'light))
#+end_src

Sadly ~doom-variable-pitch-font~ actually doesn't control that much. In this
particular case, I wish for the variable pitch font to be bigger (since in
general I'm using it for stuff like org buffers).

#+begin_src emacs-lisp
(setq mixed-pitch-set-height 14)
#+end_src

**** TODO Check that fonts exist, and if not, download them

*** Setting up theme

The theme of choice is Dracula (ðŸ§›), since it gives a pleasant and colourful
dark / \tilde{}cool\tilde{}  experience.

#+begin_src emacs-lisp
(setq doom-theme 'doom-dracula)
#+end_src

We all need more colour in our lives.

*** Window title

Sometimes I need to parse the name of Emacs windows with other scripts /
software, and I'd rather stick to standard strings to future-proof things:

#+begin_src emacs-lisp
(setq frame-title-format "%b - Emacs")
#+end_src

*** Modeline
**** Disabling showing default file encoding

I don't want to display =LF UTF-8= in the modeline, since that is the default.
Snippet taken from [[https://tecosaur.github.io/emacs-config/config.html#theme-modeline][Tecosaur's config]].

#+begin_src emacs-lisp
(defun nn/doom-modeline-conditional-buffer-encoding ()
  "Don't show file encoding if it's utf-8"
  (setq-local doom-modeline-buffer-encoding
              (unless (and (memq (plist-get (coding-system-plist buffer-file-coding-system) :category)
                                 '(coding-category-undecided coding-category-utf-8))
                           (not (memq (coding-system-eol-type buffer-file-coding-system) '(1 2))))
                t)))

(add-hook 'after-change-major-mode-hook #'nn/doom-modeline-conditional-buffer-encoding)
#+end_src

***** TODO Consider using nondefault const for =doom-modeline-buffer-encoding= instead

Since it seems like it's the more reasonable thing to do.

*** Vertical line numbers

**** Disable vertical line numbers in org

By default, we display line numbers inline for most text buffers. However I not
particularly interested in having them when I'm using org-mode (due to it coming
with an already powerful navigation system), and they also don't behave well in
buffers with variable-size fonts.

So we disable them accordingly.

#+begin_src emacs-lisp
(remove-hook! '(text-mode-hook) #'display-line-numbers-mode)
#+end_src

VoilÃ .

** Buffers

*** Better default names when in conflict

Whenever I'm working on some (nasty) framework, I tend to have to open multiple
=__init__.py= at the same time. I'd like to prefix them with the least amount of
information needed to disentangle them. In principle we could do this as
follows:

#+begin_src emacs-lisp :tangle no
(setq uniquify-buffer-name-style 'forward)
#+end_src

Sadly we can't do this as that would break =persp-mode= (hence why the above
snippet is not tangled). There's an [[github:Bad-ptr/persp-mode.el/issues/104][issue]] that tracks this problem.

*** Rename default buffer back to *scratch*

=*doom*= is nice, but I've got 15 years of muscle memory to deal with.

#+begin_src emacs-lisp
(setq doom-fallback-buffer-name "*scratch*")
#+end_src

** Wrapping

First, let's make sure to switch =visual-fill-column= on when using
=visual-line-mode=:

#+begin_src emacs-lisp
(add-hook 'visual-line-mode-hook #'visual-fill-column-mode)
#+end_src

* Tools configuration
** org-mode

This one maybe should deserve a whole level-1 heading :)

What follows is what /remains/ of my org-mode setup. Unsurprisingly, Doom + modern
org packages cover pretty much almost anything I want; compared to the past,
there's minimal setup that one needs to do to have a decent workflow. I love
this community!

*** Basic files and folders

=org-mode= tends to want to reason around a few files and directories, so we set
them most of them here.

#+begin_src emacs-lisp
(setq org-directory (file-name-as-directory (getenv "ORGDIR"))
      org-archive-location (concat org-directory ".archive/%s::")
      org-default-notes-file (concat org-directory "notes.org"))

(defvar nn-org-main-file (concat org-directory "main.org")
  "Path to file containing my main org data.")

(defvar nn-org-reading-file (concat org-directory "reading.org")
  "Path to file containing my reading list.")
#+end_src

I also employ =org-roam= to manage my knowledge base, so let's setup its directory
as ~$org-directory/kb~.

#+begin_src emacs-lisp
(setq org-roam-directory (concat
                          (file-name-as-directory org-directory)
                          "kb/"))
#+end_src

=org-roam= already enables to reach its files easily, and on top of this we also
[[*Deft][use deft]], but I'm lazy and I like to be able to reach these files easily, so
let's setup a couple of keybindings.

#+begin_src emacs-lisp
(defun nn/org-open-main()
  (interactive)
  (find-file nn-org-main-file))

(map! :leader
      :prefix-map ("n" . "notes")
      :desc "Open main org file" "i" #'nn/org-open-main)
#+end_src

*** General behavior

#+begin_src emacs-lisp
(setq org-return-follows-link t             ;; follow links on RET
      org-use-property-inheritance t        ;; inherit properties in subheadings
      org-list-allow-alphabetical t         ;; Allow to use alphabetical bullets
      org-catch-invisible-edits 'smart      ;; Be more mindful of what I delete
      ;; TODO: fix these org-export vars
      org-export-in-background t            ;; Run export queries in emacs subprocess
      org-export-with-sub-superscripts '{}  ;;require _{} / ^{} for subscripts / superscripts
      org-babel-load-languages '((dot . t)
                                 (emacs-lisp . t)
                                 (python . t)
                                 (shell . t)
                                 (R . t)))
#+end_src

*** "TODO" keywords

=TODO -> DONE= is just not enough.

#+begin_src emacs-lisp
(after! org
  (setq org-todo-keywords
       '((sequence
          "TODO(t)"
          "PROJ(p)"  ; A project.
          "STRT(s)"  ; Started.
          "HOLD(h)"  ; I've paused this.
          "WAIT(w)"  ; Waiting on someone/something.
          "DLGT(g)"  ; Delegated (hopefully with context!)
          "IDEA(i)"  ; To consider at some point.
          "LOOP(l)"  ; Recurrent tasks.
          "|"
          "DONE(d)"
          "KILL(k)")
         (sequence
          "[ ](T)"   ; TODO
          "[-](S)"   ; STRT
          "[?](W)"   ; WAIT / HOLD / DLGT
          "|"
          "[X](D)"   ; DONE
          "[k](K)")  ; KILL
         (sequence
          "TOREAD(1!)"
          "READING(2!)"
          "|"
          "READ(3!)")
         (sequence
          "|"
          "OKAY(o)"
          "YES(y)"
          "NO(n)"))
        org-todo-keyword-faces
        '(("STRT" . +org-todo-active)
          ("[-]"  . +org-todo-active)
          ("READING" . +org-todo-active)
          ("WAIT" . +org-todo-onhold)
          ("HOLD" . +org-todo-onhold)
          ("DLGT" . +org-todo-onhold)
          ("[?]"  . +org-todo-onhold)
          ("PROJ" . +org-todo-project)
          ("NO"   . +org-todo-cancel)
          ("KILL" . +org-todo-cancel)
          ("[k]"  . +org-todo-cancel))))
#+end_src

*** Timestamps

In some org buffers, I wish to have a ~last_modified~ property that auto-updates on save.

To implement this, I can use =time-stamp= which will search the first 8 lines for
the pattern below before saving, and insert a org-mode readable time-stamp if it
finds ~last_modified: []~.

#+begin_src emacs-lisp
(setq time-stamp-pattern "last_modified: %%$"
      time-stamp-format "[%Y-%02m-%02d %3a %02H:%02M]")
(add-hook 'before-save-hook 'time-stamp)
#+end_src

So easy. /*chef kiss*/

*** ~orgfmt~

I write messily, leaving destruction and despair in all my org files (in the
form of random newlines, mostly). But I dislike mess! Thus, automation to the
rescue:

#+begin_src emacs-lisp
(defun nn/org-format-heading ()
  "Formats an org heading.

The heading will be surrounded by newlines, unless other headings or drawers are
next to it."
  (org-with-wide-buffer
   ;; `org-map-entries' narrows the buffer, which prevents us from seeing
   ;; newlines before the current heading, so we do this part widened.
   (while (not (or (looking-back "\n\n" nil)
                   (save-excursion
                     (condition-case nil
                         ;; So that we don't need to deal with the fact that the
                         ;; first heading might be on line 0.
                         (progn
                           (previous-line)
                           (org-at-heading-p))
                       (error t)))))
     ;; Insert blank lines before heading.
     (insert "\n")))
  (let ((end (org-entry-end-position)))
    ;; Insert blank lines before entry content
    (forward-line)
    (while (and (org-at-planning-p)
                (< (point) (point-max)))
      ;; Skip planning lines
      (forward-line))
    (while (re-search-forward org-drawer-regexp end t)
      ;; Skip drawers. You might think that `org-at-drawer-p' would suffice, but
      ;; for some reason it doesn't work correctly when operating on hidden text.
      ;; This works, taken from `org-agenda-get-some-entry-text'.
      (re-search-forward "^[ \t]*:END:.*\n?" end t)
      (goto-char (match-end 0)))
    (unless (or (= (point) (point-max))
                (org-at-heading-p)
                (looking-at-p "\n"))
      (insert "\n"))))

(defun nn/orgfmt (&optional SCOPE)
  "Formats org buffers.

It makes sure that:

 1. Headings containing content have newlines around them;
 2. there aren't big newline blocks left around.

SCOPE determines the scope of the command; see `org-map-entries' for a list."
  (interactive)
  (org-map-entries 'nn/org-format-heading t SCOPE)
  (save-excursion
    (goto-char (point-min))
    (while (re-search-forward "\n\n\n+" nil t)
      (replace-match "\n\n"))))
#+end_src

*** Look
**** Use variable pitch fonts for prose

I want org files to use =mixed-pitch-mode=, since it is nicer to read prose in
variable pitch fonts.

#+begin_src emacs-lisp
(add-hook! 'org-mode-hook #'+org-pretty-mode #'mixed-pitch-mode)
#+end_src

**** Headings gotta pop!

I want the headings to be indented, as well as being represented using some
[[https://en.wikipedia.org/wiki/Bagua][symbols]] that roughly give me an indication of the indent level.

#+begin_src emacs-lisp
(after! org-superstar
  (setq org-superstar-headline-bullets-list '("â˜°" "â˜±" "â˜²" "â˜³" "â˜´" "â˜µ" "â˜¶" "â˜·" "â˜·" "â˜·" "â˜·")
        org-superstar-prettify-item-bullets t
        org-superstar-remove-leading-stars nil
      ))
#+end_src


Also, headings (and the title) need to standout more.

#+begin_src emacs-lisp
(after! org
  (custom-set-faces!
    '(org-document-title :height 1.3)
    '(org-level-1 :inherit outline-1 :weight extra-bold :height 1.4)
    '(org-level-2 :inherit outline-2 :weight bold :height 1.15)
    '(org-level-3 :inherit outline-3 :weight bold :height 1.12)
    '(org-level-4 :inherit outline-4 :weight bold :height 1.09)
    '(org-level-5 :inherit outline-5 :weight semi-bold :height 1.06)
    '(org-level-6 :inherit outline-6 :weight semi-bold :height 1.03)
    '(org-level-7 :inherit outline-7 :weight semi-bold)
    '(org-level-8 :inherit outline-8 :weight semi-bold)))
#+end_src

When cycling the headings down, I don't want to see actual ellipsis.

#+begin_src emacs-lisp
(after! org (setq org-ellipsis " â–¾ "))
#+end_src

When using simple list, I want different levels to have different bullets.

#+begin_src emacs-lisp
(setq org-list-demote-modify-bullet '(("+" . "-")
                                      ("-" . "+")))
#+end_src

**** Indentation

I want everything left-justified.

#+begin_src emacs-lisp
(after! org
  (setq org-startup-indented nil  ;; I don't like indents
        org-adapt-indentation nil))
#+end_src
*** Capture

#+begin_src emacs-lisp
(after! org-capture
  (setq org-capture-templates
        `(("i" "Quick inbox" entry (file+headline nn-org-main-file "Inbox")
           "* TODO %^{Task description}"
           :immediate-finish t)
          ("I" "Inbox" entry (file+headline nn-org-main-file "Inbox")
           "* TODO %?")
          ;; Dates
          ("." "Today" entry (file+headline nn-org-main-file "Inbox")
           ,(string-join '("* TODO %^{Task description (scheduled today)}"
                           "SCHEDULED: %t") "\n")
           :immediate-finish t)
          ("d" "Date")
          ("ds" "Scheduled" entry (file+headline nn-org-main-file "Inbox")
           ,(string-join '("* TODO %?"
                           "SCHEDULED: %^{Scheduled date}t") "\n"))
          ("dd" "Deadline" entry (file+headline nn-org-main-file "Inbox")
           ,(string-join '("* TODO %?"
                           "DEADLINE: %^{Deadline date}t") "\n"))
          ("r" "reading" entry (file+headline nn-org-reading-file "Inbox")
           "* TOREAD %:annotation \n%:i\n %i"
           :immediate-finish t))))
#+end_src

~org-capture~ by default is mapped to =SPC-X= but we want it accessible via =SPC-x=,
which normally is mapped to ~doom/open-scratch-buffer~. However this last function
is also available at =SPC b x=), so it's not a major loss.

#+begin_src emacs-lisp
(map! :after org
      :leader
      :desc "Org capture" "x" #'org-capture)
#+end_src

**** MacOS setup

To setup capture on MacOS, save the following script as =org-capture.app=
using =Script Editor= into =/Applications=:

#+begin_src sh :tangle no
on open location this_URL
 do shell script "/usr/local/Cellar/emacs-plus@27/27.1/bin/emacsclient \"" & this_URL & "\""
end open location
#+end_src

Then add this to =Info.plist= inside =org-capture.app=:

#+begin_src xml :tangle no
<key>CFBundleURLTypes</key>
<array>
    <dict>
        <key>CFBundleURLName</key>
        <string>org-protocol handler</string>
        <key>CFBundleURLSchemes</key>
        <array>
        <string>org-protocol</string>
        </array>
    </dict>
</array>
#+end_src

Testing with the following:

#+begin_src sh :tangle no
/usr/local/Cellar/emacs-plus@27/27.1/bin/emacsclient \
  "org-protocol://capture?template=w&url=testurl&title=testtitle&body=testbody"
#+end_src

Afterwards one can for instance use some javascript to make a bookmark as
follows:

#+begin_src js :tangle no
javascript:location.href='org-protocol://capture?template=w'
    + '&url=' + encodeURIComponent(window.location.href)
    + '&title='+encodeURIComponent(document.title)
    + '&body='+encodeURIComponent(window.getSelection());
#+end_src

Chrome annoying also disabled the ability to easily whitelist protocols. To
disable the confirmation window, run:

#+begin_src sh :tangle no
$ defaults write $HOME/Library/Preferences/com.google.Chrome.plist URLWhitelist -array-add "org-protocol://*"
#+end_src

*** Agenda

First, let's make sure that the agenda pulls all the files in the org directory
as well as the project directory. The former are used for standard task
management, while the latter are used both as knowledge bases for the project
and task tracking.

#+begin_src emacs-lisp
(setq org-agenda-files (list org-directory
                             (concat org-directory "kb/projects")))
#+end_src

**** Behaviour

When opening an item from the agenda, I want the context (parent heading and
siblings) to be visible.

#+begin_src emacs-lisp
(add-hook 'org-agenda-after-show-hook 'org-reveal)
#+end_src

I also don't want tasks that are blocked (like =PROJ= ones, which have multiple
sub-TODOs) to be dimmed in the view, otherwise I have issues on days when they
are scheduled.

#+begin_src emacs-lisp
(after! org
  (setq org-agenda-dim-blocked-tasks nil))
#+end_src

**** Agenda commands

I make a good amount of use of habits, and I like to keep them separate from the
standard today view.

#+begin_src emacs-lisp
(defun air-org-skip-subtree-if-priority (priority)
  "Skip an agenda subtree if it has a priority of PRIORITY.

PRIORITY may be one of the characters ?A, ?B, or ?C."
  (let ((subtree-end (save-excursion (org-end-of-subtree t)))
        (pri-value (* 1000 (- org-lowest-priority priority)))
        (pri-current (org-get-priority (thing-at-point 'line t))))
    (if (= pri-value pri-current) subtree-end nil)))

(defun air-org-skip-subtree-if-habit ()
  "Skip an agenda entry if it has a STYLE property equal to \"habit\"."
  (let ((subtree-end (save-excursion (org-end-of-subtree t))))
    (if (string= (org-entry-get nil "STYLE") "habit") subtree-end nil)))

(setq org-agenda-custom-commands
      '(("d" "High-pri, habits, agenda, and all TODOs"
        ((tags "PRIORITY=\"A\""
               ((org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
                (org-agenda-overriding-header "High-priority TODOs:")))
         (agenda ""
                 ((org-agenda-skip-function '(org-agenda-skip-entry-if 'nottodo '("LOOP")))
                  (org-agenda-span 'day)
                  (org-agenda-start-day nil)
                  (org-agenda-overriding-header "Recurrent tasks:")))
         (agenda ""
                 ((org-agenda-skip-function '(org-agenda-skip-entry-if 'todo '("LOOP")))
                  (org-agenda-span 'week)
                  (org-agenda-start-day "-1d")
                  (org-agenda-overriding-header "Weekly schedule:")))
         (alltodo ""
                  ((org-agenda-skip-function '(or (air-org-skip-subtree-if-habit)
                                                  (air-org-skip-subtree-if-priority ?A)
                                                  (org-agenda-skip-if nil '(scheduled deadline))))
                   (org-agenda-overriding-header "ALL normal priority tasks:"))))
        (
         (org-agenda-compact-blocks nil)))))

(setq org-agenda-include-diary t)
(setq org-habit-show-habits-only-for-today nil)
(setq org-habit-show-all-today t)
#+end_src

**** Keybindings

Doom by default uses =SPC o a= for =org-agenda=, however I use it so often that the
extra "n a d" is way too many strokes.

#+begin_src emacs-lisp
(after! org
  (defun nn/open-default-agenda ()
    (interactive)
    (org-agenda nil "d"))

  (map! :leader "a" #'nn/open-default-agenda))
#+end_src

Furthermore, I want to quickly be able to save all buffers, and to have a view
of the context of each agenda item whenever I wish it. Thus, I'm remapping =w= and
=f= so that they are actually useful in the agenda map.

#+begin_src emacs-lisp
(after! org
  (map! :map evil-org-agenda-mode-map
        :m "w" #'org-save-all-org-buffers
        :m "f" #'org-agenda-follow-mode))
#+end_src

I also want =j= and =k= to jump to agenda items instead of following the textual
newlines (since I can search if I /really/ want to copy dates / times / headers /
etc. ).

#+begin_src emacs-lisp
(after! org
  (map! :map org-agenda-mode-map
        [remap org-agenda-next-line] #'org-agenda-next-item
        [remap org-agenda-previous-line] #'org-agenda-previous-item))
#+end_src

*** Logging and clocking

I generally want a timestamp when:
 - setting a task to a done state
 - rescheduling a task (including moving a deadline)

I also want all this information into a drawer, so that I don't see it unless I
really need it.

#+begin_src emacs-lisp
(setq org-log-into-drawer t     ;; defaults to LOGBOOK
      org-log-done 'time
      org-log-reschedule 'time
      org-log-redeadline 'time)
#+end_src

*** Exporting

I hate it that exporting big files locks emacs -- so, let's make it happen in
the background.

#+begin_src emacs-lisp
(setq org-export-in-background t)
#+end_src

*** Habits

#+begin_src emacs-lisp
(add-to-list 'org-modules 'org-habit)
#+end_src

*** Refile

I want to be able to create headings when I refile (but with confirmation to
partially deal with typos).

#+begin_src emacs-lisp
(setq org-refile-allow-creating-parent-nodes 'confirm)
#+end_src

I also want to refile only on non-done states.

#+begin_src emacs-lisp
(defun nn/verify-refile-target ()
  "Exclude done todo states from refile targets"
  (not (member (nth 2 (org-heading-components)) org-done-keywords)))

(setq org-refile-target-verify-function 'nn/verify-refile-target)
#+end_src

*** Spellcheck

We use =aspell= to spellcheck using the standard US dictionary, on top of which we
add a bunch of private words.

#+begin_src emacs-lisp
(setq ispell-dictionary "en_US"
      ispell-personal-dictionary (substitute-in-file-name "~/Dropbox/aspell/en_US.pws"))
#+end_src

NOTE: if you notice that =spell-fu= is flagging all words as incorrect, check that
(1) aspell is installed, and (2) =~/.emacs.d/.local/etc/spell-fu= doesn't contain
any files (since any files might be broken cache that the library doesn't know
how to deal with).

*** Roam

First, let's make it so that the database doesn't pollute any useful
directories:

#+begin_src emacs-lisp
(setq org-roam-db-location (concat
                            (file-name-as-directory doom-cache-dir)
                            "org-roam.db"))
#+end_src

Next, let's use directories as roam tags, since it's useful (at least) for my
compendium files.

#+begin_src emacs-lisp
(setq org-roam-tag-sources '(prop all-directories))
#+end_src

Finally, it's time to set the capture templates that are exclusive to =org-roam=.

#+begin_src emacs-lisp

(defvar nn-roam-header (string-join '("#+title: ${title}"
                                      "#+created: %u"
                                      "#+last_modified: %U"
                                      ""
                                      " - related :: "
                                      "") "\n")
  "Boilerplate header used in knowledge base files.")

(setq org-roam-capture-templates
      `(("d" "default" plain (function org-roam--capture-get-point) "%?"
         :file-name "${slug}"
         :head ,nn-roam-header
         :unnarrowed t)
        ("p" "project" plain (function org-roam--capture-get-point) "%?"
         :file-name "projects/${slug}"
         :head ,nn-roam-header
         :unnarrowed t)
        ("h" "human" plain (function org-roam--capture-get-point) "%?"
         :file-name "humans/${slug}"
         :head ,nn-roam-header
         :unnarrowed t)
        ("r" "review" plain (function org-roam-capture--get-point) "%?"
         :file-name "reviews/${slug}"
         :head ,nn-roam-header
         :unnarrowed t)))
#+end_src

*** Journal

I want a daily journal, with sensible ISO-approvedâ„¢ date format for the file.
Originally I was using =org-journal= for this, but truthfully it never really
provided any particular value for me, beyond serving as an easy-to-use daily
template for creating the journal file.

Thus, I now make use of =org-roam= "dailies" facilities.

#+begin_src emacs-lisp
(setq org-roam-dailies-capture-templates
      `(("d" "daily" plain (function org-roam-capture--get-point)
         ""
         :immediate-finish t
         :file-name "journal/%<%Y-%m-%d>"
         :head ,(string-join '("#+title: %<%Y-%m-%d>"
                               "#+created: %u"
                               "#+last_modified: %U") "\n")
         :unnarrowed t)))
#+end_src

Finally, I like to start the week by listing overall goals, and I don't want
that to have a proper journal entry. Thus, I need some functions and nice
bindings.

=SPC n j= by default is used for =org-journal=, but we can remap it.

#+begin_src emacs-lisp
(after! org-roam
  (map! :leader
        :prefix-map ("n" . "notes")
        (:prefix ("j" . "journal")
         :desc "Open daily journal" "j" #'org-roam-dailies-today
         :desc "Open tomorrow's journal" "t" #'org-roam-dailies-tomorrow
         :desc "Open yesterday's journal" "y" #'org-roam-dailies-yesterday
         :desc "Open journal at date" "d" #'org-roam-dailies-date)))
#+end_src

**** Logging meetings

I also want the ability to add meetings to daily entries, but the templating
system built with =org-roam= doesn't allow to easily disable the search system. I
don't want to mess with its functions. Directly using =org-capture= is also
painful, since I would need to maybe-create the dailies file, which invokes
capture, which in turn cannot be easily done inside another capture process...
So, let's just custom make our own "capture" function.

#+begin_src emacs-lisp
(after! org-roam
  (defun nn/org-roam-dailies-today-meeting ()
    (interactive)
    (org-roam-dailies-today)
    (let ((file-name (expand-file-name (format-time-string "journal/%Y-%m-%d.org")
                                       org-roam-directory)))
      (progn (set-buffer (org-capture-target-buffer file-name))
             (goto-char (point-max))
             (insert (format-time-string "\n\n* %02H:%02M Meeting w/ %  :meeting:"))
             (search-backward-regexp "%")
             (delete-char 1))))

  (map! :leader
        :prefix-map ("n" . "notes")
        (:prefix ("j" . "journal")
         :desc "Log meeting now" "m" #'nn/org-roam-dailies-today-meeting)))
#+end_src

*** Bibtex setup

We use all sort of packages to manage our bibliography. Here's where we
configure them.

First, we make sure that =reftex, =bibtex-completion=, and the rest of packages
know where my bibliography is.

#+begin_src emacs-lisp
(defvar nn-bibliography-path (concat (file-name-as-directory org-directory) "library.bib")
  "Path to centralised biblio file.")
  ;; :type 'string)

(defvar nn-bibliography-notes-path (concat (file-name-as-directory org-directory) "kb/reviews/")
  "Path to notes directory")
  ;; :type 'string)
#+end_src

*** LaTeX in org buffers

We use ~org-fragtog~ to be able to modify LaTeX snippets simply by moving the
cursor on them.

#+begin_src emacs-lisp
(add-hook 'org-mode-hook 'org-fragtog-mode)
#+end_src

We then want them to look alright, so let's make org use a sans font, as well as
highlighting them:

#+begin_src emacs-lisp
(after! org
  (setq org-highlight-latex-and-related '(native script entities)
        org-format-latex-header "\\documentclass{article}
\\usepackage[usenames]{color}

\\usepackage[T1]{fontenc}
\\usepackage{mathtools}
\\usepackage{textcomp,amssymb}
\\usepackage[makeroom]{cancel}

\\usepackage{booktabs}

\\pagestyle{empty}             % do not remove
% The settings below are copied from fullpage.sty
\\setlength{\\textwidth}{\\paperwidth}
\\addtolength{\\textwidth}{-3cm}
\\setlength{\\oddsidemargin}{1.5cm}
\\addtolength{\\oddsidemargin}{-2.54cm}
\\setlength{\\evensidemargin}{\\oddsidemargin}
\\setlength{\\textheight}{\\paperheight}
\\addtolength{\\textheight}{-\\headheight}
\\addtolength{\\textheight}{-\\headsep}
\\addtolength{\\textheight}{-\\footskip}
\\addtolength{\\textheight}{-3cm}
\\setlength{\\topmargin}{1.5cm}
\\addtolength{\\topmargin}{-2.54cm}
% my custom stuff
\\usepackage{arev}
\\usepackage{arevmath}"))
#+end_src

*** Deft

I use ~deft~ for searching my org files (though I should explore more what
org-roam gives me...), so I set it up here:

#+begin_src emacs-lisp
(setq deft-directory org-directory
      deft-extensions '("org")
      deft-recursive t)
#+end_src

*** Other stuff

#+begin_src emacs-lisp
(after! org
  (map! :localleader
        :map org-mode-map
        "M-n" #'org-next-visible-heading
        "M-p" #'org-previous-visible-heading))
#+end_src

*** org-anki

#+begin_src emacs-lisp
;; (use-package! org-anki
;;   :after org
;;   :commands (org-anki-push-notes
;;              org-anki-insert-note
;;              org-anki-retry-failure-notes)
;;   :hook (org-mode . org-anki-mode)
;;   :config
;;   (map! :map org-mode-map
;;         :localleader
;;         (:prefix ("z" . "anki")
;;          :desc "Push to Anki" "p" #'org-anki-push-notes
;;          :desc "Push failed to Anki" "P" #'org-anki-retry-failure-notes
;;          :desc "Insert Anki card" "i" #'org-anki-insert-note)))
#+end_src

** Generic UX changes

#+begin_src emacs-lisp
(setq doom-scratch-initial-major-mode 'lisp-interaction-mode)

;; Switch to new window when splitting
(setq evil-split-window-below t
      evil-vsplit-window-right t
      ;; isearch
      isearch-lazy-count t
      isearch-allow-scroll 'unlimited
      ;; magit
      magit-save-repository-buffers 'dontask
      ;; Don't restore window config after quitting magit
      magit-inhibit-save-previous-winconf t)

(add-to-list 'ispell-skip-region-alist '(org-property-drawer-re))
(add-to-list 'ispell-skip-region-alist '("~" "~"))
(add-to-list 'ispell-skip-region-alist '("=" "="))

#+end_src

** Editing setup

Most of =evil= is already well configured with =doom=, however I like to do some
additional tweaking:

#+BEGIN_SRC emacs-lisp
(setq
 ;; All changes are considere one block in insert mode by default. This is not
 ;; great most of the time, so we make evil use Emacs' heuristics to group
 ;; changes.
 evil-want-fine-undo t)
#+END_SRC

** File Templates

The =file-templates= module introduces a templating system that is used to
kickstart the content of certain buffers, depending on their name.

I don't want to use the ones pre-made by doom, so I point the module to my own
directory;

#+begin_src emacs-lisp
(setq +file-templates-dir (concat doom-private-dir "templates/files/"))
#+end_src

** Atomic Chrome

=atomic-chrome= is a package that enables to use emacs for text boxes in Chrome. I
set it up here to use =markdown-mode= whenever editing text (though =org-mode= is
also a good option). The [[https://chrome.google.com/webstore/detail/ghosttext/godiecgffnchndlihlpaajjcplehddca][GhostText add-on]] is required for this to work.

#+begin_src emacs-lisp
(use-package! atomic-chrome
  :after-call focus-out-hook
  :config
  (setq atomic-chrome-default-major-mode 'markdown-mode
        atomic-chrome-buffer-open-style 'frame)
  (atomic-chrome-start-server))
#+end_src

** Mathpix

#+begin_src emacs-lisp
(use-package! mathpix
  :after org
  :config
  (setq mathpix-app-id (getenv "MATHPIX_API_ID")
        mathpix-app-key (getenv "MATHPIX_API_KEY")
        mathpix-screenshot-method "screencapture -i %s")
  (map! :leader
        :prefix-map ("j" . "useful")
        :desc "Take Mathpix screenshot" "s" #'mathpix-screenshot))
#+end_src

* Language configuration

** Python

#+begin_src emacs-lisp
(setq conda-anaconda-home "~/.conda")
#+end_src

** Emacs lisp

*** Better eval-sexp

I hate to manually having to do forward-list all the time I'm writing elisp and
want to evaluate the sexp. The great thing is that automating these stuff is just a function definition away.

#+begin_src emacs-lisp
(defun nn/eval-surrounding-sexp (levels)
  "Evaluates surrounding sexp."
  (interactive "p")
  (save-excursion
    (up-list (abs levels))
    (eval-last-sexp nil)))

(defun nn/eval-print-surrounding-sexp (levels)
  "Grabs surrounding sexp and eval-prints it."
  (interactive "p")
  (save-excursion
    (up-list (abs levels))
    (eval-print-last-sexp nil)))

(defun nn/eval-next-sexp ()
  "See eval-last-sexp."
  (interactive)
  (save-excursion
    (forward-sexp)
    (call-interactively 'eval-last-sexp)))

(defun nn/eval-print-next-sexp ()
  "See eval-print-last-sexp."
  (interactive)
  (save-excursion
    (forward-sexp)
    (call-interactively 'eval-print-last-sexp)))

(defun nn/eval-current-form ()
  "Looks for the current [def|set|map|use]* command and evaluates it."
  (interactive)
  (save-excursion
    (search-backward-regexp "(def\\|(set\\|(map\\|(use")
    (forward-list)
    (call-interactively 'eval-last-sexp)))

(defun nn/eval-print-current-form ()
  "Looks for the current [def|set|map|use]* command and eval-prints it."
  (interactive)
  (save-excursion
    (search-backward-regexp "(def\\|(set\\|(map\\|(use")
    (forward-list)
    (call-interactively 'eval-print-last-sexp)))
#+end_src

*** Keybindings

Using emacs keybindings for evaluating elisp expressions is... not that great.
So we rebind everything to =<leader> e=.

#+begin_src emacs-lisp
(map!
 :leader
      :prefix-map ("e" . "eval")
      :desc "Eval current form"            "e" #'nn/eval-current-form
      :desc "Eval+print current form"      "E" #'nn/eval-print-current-form
      :desc "Eval last s-exp"              "l" #'eval-last-sexp
      :desc "Eval+print last s-exp"        "L" #'eval-print-last-sexp
      :desc "Eval next s-exp"              "n" #'nn/eval-next-sexp
      :desc "Eval next s-exp"              "N" #'nn/eval-print-next-sexp
      :desc "Eval surrounding s-exp"       "s" #'nn/eval-surrounding-sexp
      :desc "Eval+print surrounding s-exp" "S" #'nn/eval-print-surrounding-sexp
      :desc "Eval function"                "f" #'eval-defun
      :desc "Eval buffer"                  "b" #'+eval/buffer
      :desc "Eval region"                  "r" #'+eval:region
      :desc "Open REPL"                    "R" #'+eval/open-repl-other-window)
#+end_src
